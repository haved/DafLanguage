#import <stdio>
#import <random>
#import <time>

class Entity {
	smell:int;
	name:char[];
	points:int;
}

class Room {
	smell:int;
	entity:&Entity;
	shortcut:int;
}

class EntityArrayContainer implements destructable
{
	array:Entity[];
	def EntityArrayContainer(self, array:Entity[]) {
		self.array = array;
	}	

	def ~EntityArrayContainer() {
		delete[] array;
	}
}

def ROOM_COUNT:=100;
def APPROX_SHORTCUT_COUNT:=6;

def BASE_ENTITY_COUNT:=6;
def EXTRA_ENTITY_COUNT:=3;
def BASE_ENTITY_SMELL:=4;
def EXTRA_ENTITY_SMELL:=4;
def GOAL_ENTITY_SMELL:=10;
def ENTITY_NAMES:=char[][]{"Ball", "Bird", "Lump of Coal", "Trump", "Goat", "Santa", "Breadstick"};
def GOAL_ENTITY_NAME:="Chest";
def BASE_ENTITY_ANTIPOINTS:=5;
def EXTRA_ENTITY_ANTIPOINTS:=4;
def GOAL_ENTITY_POINTS:=20;

def main:=() -> int{
	stdio::printf("Making cave with "+ROOM_COUNT+" rooms!\n");
	random::seed(time::systemTimeMillis());
	let mut rooms:Room[ROOM_COUNT];
        
	for i in 0=..<ROOM_COUNT {
		rooms[i].smell=0;
		rooms[i].entity=NULL;
		if(random::nextInt(ROOMS)<APPROX_SHORTCUT_COUNT) {
			rooms[i].shortcut=0; //Temporairly
			let mut target:=-1;
			while(target==-1) {
				let guess:=random::nextInt(ROOM_COUNT);
				if(rooms[guess].shortcut==-1)
					target=guess;
			}
			rooms[   i  ].shortcut = target;
			rooms[target].shortcut = i;
		} else
			rooms[i].shortcut=-1;
	}
	
	let entityCount:=random::baseNextInt(BASE_ENTITY_COUNT, EXTRA_ENTITY_COUNT);
	stdio::printf("Adding {} smelly items. You are looking for a smelly "+GOAL_ENTITY_NAME+" with a smell level of "+GOAL_ENTITY_SMELL+"\n", entityCount);	

	let mut entities:=new Entity[entityCount];
	let mut entitiesContainer:EntityArrayContainer(entities);
	entities[0].smell=GOAL_ENTITY_SMELL;
	entities[0].name=GOAL_ENTITY_NAME;
	entities[0].points=GOAL_ENTITY_POINTS;
	for i in 1=..<entities.length {
		entities[i].smell = random::baseNextInt(BASE_ENTITY_SMELL, EXTRA_ENTITY_SMELL);
		entities[i].name  = ENTITY_NAMES[random::nextInt()];
		entities[i].points= -random::baseNextInt(BASE_ENTITY_ANTIPOINTS, EXTRA_ENTITY_ANTIPOINTS);
	}
	
	def updateSmellInRooms:=(room:int, smell:int) {
		if(rooms[room].smell>=smell)
			return;
		rooms[room].smell = smell;
		if(room>1)
			updateSmellInRoom(room-1, smell-1);
		if(room<ROOM_COUNT-1)
			updateSmellInRoom(room+1, smell-1);
		if(rooms[room].shortcut!=-1)
			updateSmellInRoom(rooms[room].shortcut, smell-1);
	}

	for i in 0=..<entityCount {
		let roomChoice:=random::nextInt(ROOM_COUNT);
		if(rooms[roomCoice].entity!=NULL)
			retry;
		rooms[roomChoice].entity = &entities[i];
		updateSmellInRooms(roomChoice, entities[i].smell);
	}

	//The world is set up!
	
	stdio::printf("\n\n=== Welcome to cave game in daf! ===\n\n");

	let mut playerPos:= ROOM_COUNT/2;
	let mut stuff:=0;
	let mut points:=0;
	let mut moves:=0;
	while(true) {
		let room:=&mut rooms[playerPos];
		stdio::printf("\nYou are in room {}.\nIt has a smell level of {}.\n", playerPos, room.smell);
		if(room.entity!=NULL) {
			stdio::printf("You found a smelly {}. You picked it up but the room still smells.\n", room.entity.name);
			points+=room.entity.points;
			stuff++;
			if(room.entity.points==GOAL_ENTITY_POINTS)
				break;
			room.entity = NULL;
		}
		if(room.shortcut!=-1) {
			stdio::printf("There is an opening to room {} here.\n", room.shortcut);
		
		stdio::printf("Enter room: ");
		while(true) {
			let mut newPos:int=-1; 
			stdio::readInt(&mut newPos);
			if(newPos<0 | newPos>=ROOM_COUNT) {
				stdio::prinft("The room has to be a number between 0 and {} exclusive!");
				continue;
			}
			if(newPos==playerPos) {
				stdio::printf("You are already in that room!");
				continue;
			}
			playerPos=newPos;
			break;
		}
	}

	stdio::printf("You won! You found {} stuff, got {} points and moved {} times.\n", stuff, points, moves);

	//Entities are automaticly deleted here!
}
