#import "math.daf"

def a:=5;
def b:=5.f;
def c:=5.5f;
def d:=.5f;
def e:=6.;
def f:=5.6;
def g:=.6;

def x:=Math2.sin();

def TEXT:="halla";
def NUMBER:=5;
def BYTE:u8=4;

def WIDTH:=1600;
def HEIGHT:=900;
def RADIUS:=50;

def main:=(argc:string[]) {
	let ball:BallEntity(Color(), WIDTH/2-RADIUS, HEIGHT/2-RADIUS, RADIUS); //Note how Color() is in that scope
	let world:World(WIDTH, HEIGHT, &ball);
	
	def SET_DELTA:=1/60f;
	let mut elapsedTime := 0;
	
	while(!shouldClose()) {
		world.updateTime(SET_DELTA, elapsedTime);
		world.doLoop();
		elapsedTime+=SET_DELTA;
	}

	let ole:&Entity = new BallEntity();
	world.entity = ole;
	world.doLoop();
	delete ole;

	let number:=10;
	let n_ptr:=&number; //n_ptr is actually a reference to number.
	let mut mutNumber:=12;
	mutNumber++;
	let mut m_ptr:=&mutNumbr;
	//*m_ptr += 1; //Nope. m_ptr is not a &mut reference
	let mut kopi:=*m_ptr;
	//m_ptr:=&mut mutNumber; // m_ptr is a &mut s32, not &s32 
	let mut sos_ptr:&s32=&number;
	//*my_ptr += 1; Does not work. my_ptr is not a mut reference
	let mut final_ptr:=&mut mutNumber;
	*final_ptr+=4;
	final_ptr=&mut kopi;
	*final_ptr-=kopi;
	my_ptr = final_ptr //A muatble reference can turn into an immutable one, but not the other way around.

	let mut per:&Entity = new BallEntity(Color(255,0,255), 400, 500, 50);
	per.update(world); //This is possible even though the pointer isn't mutable!
	delete per;
	
	let paal:SmallEntity(50, 40, 100, 300);
	let leif:SmallEntity(600, 20, 54, 33);
	//paal = leif; //Nope. paal ain't mutable
	paal.update(&world); //Possbile
	
}

def shouldClose:=()->boolean {
	return false;
}

pub class World {
	width:int;
	height:int;
	elapsedTime:float;
	deltaTime:float;

	myFavoriteEntity:&Entity;
	
	def World:=(&self, width:int, width:int, entity:Entity*) {
		self.myFavouriteEntity = entity;
		self.width = width;
		self.height = height;
	}

	def doLoop(&self) {
		self.myFavoriteEntity.update(&world);
		//self.canvas->Clean();
		self.myFavouriteEntiy.render(&world);
		//self.canvas.SwapBuffers();
	}

	def updateTime(&self, delta:float, elapsed:float) {
		self.deltaTime = delta;
		self.elapsedTime = elapsed;
	}
}

pub interface UpdateRender {
	Update:(&self, world:&World); //It's not pretty, but it's really not the same as &world:World 
	Render:(&self, world:&World);
}

pub abstract class Entity implements UpdateRender {
	x:int;
	y:int;
	width:int;
	height:int;
	
	//Constructor
	def Entity:=(&self, x:int, y:int, width:int, height:int) {
		self.x = x;
		self.y = y;
		self.width = width;
		self.height = height;
	}

	def impl Update:=(&self, world:&World) {
		self.MakeInBounds(world);
	}

	def MakeInBounds:=(&self, world:&World) {
		self.x = Math::max( 0, Math::min( world->width,  self.x+self.width  ) )
		self.y = Math::max( 0, Math::min( world->height, self.y+self.height ) )
	}
}

pub class Color {
	red:u8;
	green:u8;
	blue:u8;
	
	//The constructor
	def Color:=(&self, red:u8, green:u8, blue:u8) {
		self.red   = red;
		self.green = green;
		self.blue  = blue;
	}
}

class BallEntity extends Entity {
	color:Color;

	def BallEntity:=(&self, color:Color, x:int, y:int, diameter:int) {
		/*Call parent constructor*/
		Entity::Entity(self, x, y, diameter, diameter);
		self.color = color;
	}
	
	def impl Update:=(&self, world:&World) {
		self.x+=cast(int) sin(world->elapsedTime)*world->deltaTime;
		base.update(world);
	}

	def impl Render:=(&self, world:&World) {
		/*Imaginary render code
		c := world->GetCanvas()
		c->draw
		*/
	}
}

#import "AudioPlayer.daf"
#import "Time.daf"

def VOLUME:=10000
def DEFAULT_FREQ = 440
def SAMPLE_RATE 44100;

pub def PlaySine:=(freq:int) {
	let mut freqCounter:=0;
	
	let desiredSpec:AudioSpec;
	desiredSpec.freq = SAMPLE_RATE;
	desiredSpec.format = AudioSpec::AUDIO_S16SYS;
	desiredSpec.channels = 1;
	desiredSpec.samples = 512;
	desiredSpec.callback = (streamIn:u8[]) inscope {
		let stream:=cast(s16[]) streamIn;
		let len=stream.len();
		for (let mut i:=0; i < len; i++) {
			freqCounter += freq;
			stream[i]=cast(s16)VOLUME*sin(freqCounter * TAU/SAMPLE_RATE)
		}
	}
	AudioPlayer::OpenAudio(&desiredSpec);
	AudioPlayer::PauseAudio(0);
	Time::Delay(3000);
	freq = freq/2;
	Time::Delay(3000)
	AudioPlayer::PauseAudio(1);
	Time::Delay(500);
	AudioPlayer::PauseAudio(0);
	freq = 4*freq;
	Time::Delay(2000);
	freq = freq/2;
	Time::Delay(3000);
	AudioPlayer::CloseAudio();
}
